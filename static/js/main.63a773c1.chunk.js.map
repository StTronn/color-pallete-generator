{"version":3,"sources":["utils/stats-utils.js","utils/clustering.js","components/Pallete.js","App.js","serviceWorker.js","index.js"],"names":["mean","data","reduce","total","current","length","meanPoint","theMeanPoint","i","push","map","x","rangeOf","min","max","stats","rangesOf","ranges","euclideanDistance","a","b","Math","infinity","sum","pow","sqrt","clusterDataPoints","centroids","clusters","forEach","point","nearestCentroid","centroid","indexOf","getNewCentroids","cluster","Array","prototype","equals","array","this","l","Object","defineProperty","enumerable","kMeans","k","oldClusters","converged","iterations","r","floor","random","initialiseCentroidsRandomly","console","log","some","ColorBox","styled","div","props","color","Cointainer","Pallete","colors","key","generatePallete","allColours","g","round","componentToHex","c","hex","toString","App","ctx","canvas","useState","setColors","canvasRef","useRef","useEffect","getContext","fillStyle","fillRect","width","height","className","type","onChange","e","reader","FileReader","onload","event","img","Image","src","target","result","drawImage","getImageData","readAsDataURL","files","loadImage","ref","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.63a773c1.chunk.js","sourcesContent":["/**\n * Calculates the mean value of a one-dimensional dataset\n * @param {Array} data - data set\n * @return {Number} mean value of data set\n */\nfunction mean(data) {\n  return data.reduce((total, current) => (total += current), 0) / data.length;\n}\n\n/**\n * Calculates the mean point of an n-dimensional dataset\n * @param {Array} data - data set\n * @return {Array} mean point of data set\n */\nfunction meanPoint(data) {\n  var theMeanPoint = [];\n  if (data.length != 0) {\n    for (let i = 0; i < data[0].length; i++) {\n      theMeanPoint.push(mean(data.map((x) => x[i])));\n    }\n  }\n  return theMeanPoint;\n}\n\n/**\n * Calculates the range of a one-dimensional data set\n * @param {Array} data - data set\n * @return {Number} range - range of the data set\n */\nfunction rangeOf(data) {\n  return data.reduce(\n    function (total, current) {\n      if (current < total.min) {\n        total.min = current;\n      }\n      if (current > total.max) {\n        total.max = current;\n      }\n      return total;\n    },\n    { min: data[0], max: data[0] }\n  );\n}\n\n/**\n * Calculates the ranges of each 'component' in an n-dimensional data set\n * @param {Array} data - data set\n * @return {Number} range - range of the data set\n */\nfunction rangesOf(data) {\n  var ranges = [];\n  for (let i = 0; i < data[0].length; i++) {\n    ranges.push(rangeOf(data.map((x) => x[i])));\n  }\n  return ranges;\n}\n\nexport { mean, meanPoint, rangeOf, rangesOf };\n\n","import { mean, meanPoint, rangeOf, rangesOf } from \"./stats-utils\";\n\nconst stats = { mean, meanPoint, rangeOf, rangesOf };\n\n// Method for comparing arrays (because JavaScript doesn't provide this for some reason)\nArray.prototype.equals = function (array) {\n  // if the other array is a falsy value, return\n  if (!array) return false;\n\n  // compare lengths - can save a lot of time\n  if (this.length != array.length) return false;\n\n  for (var i = 0, l = this.length; i < l; i++) {\n    // Check if we have nested arrays\n    if (this[i] instanceof Array && array[i] instanceof Array) {\n      // recurse into the nested arrays\n      if (!this[i].equals(array[i])) return false;\n    } else if (this[i] != array[i]) {\n      // Warning - two different object instances will never be equal: {x:20} != {x:20}\n      return false;\n    }\n  }\n  return true;\n};\n// Hide method from for-in loops\nObject.defineProperty(Array.prototype, \"equals\", { enumerable: false });\n\n/**\n * Generates a random integer in the closed interval specified by a and b\n * @param {Number} a - lower bound\n * @param {Number} b - upper bound\n * @return {Number} randomInt - random integer generated\n */\nfunction randomIntBetween(a, b) {\n  return Math.floor(Math.random() * (b - a + 1)) + a;\n}\n\n/**\n * Calculates the Euclidean distance between two points.\n * @param {Array} a - first point\n * @param {Array} b - second point\n * @return {Number} distance - Euclidean distance between the points\n */\nfunction euclideanDistance(a, b) {\n  if (a.length != b.length) {\n    //throw 'Error calculating Euclidean distance. Input vectors must have same number of dimensions!';\n    return Math.infinity;\n  }\n  var sum = 0;\n  for (let i = 0; i < a.length; i++) {\n    sum += Math.pow(b[i] - a[i], 2);\n  }\n  return Math.sqrt(sum);\n}\n\n/**\n * Initialises the centroids for the k-means algorithm\n * @param {Array} data - data set\n * @param {Number} k - number of clusters/centroids\n * @return {Array} centroids - array of centroid vectors\n */\nfunction initialiseCentroidsRandomly(data, k) {\n  var ranges = stats.rangesOf(data);\n  var centroids = [];\n  for (let i = 0; i < k; i++) {\n    var centroid = [];\n    for (var r in ranges) {\n      centroid.push(randomIntBetween(ranges[r].min, ranges[r].max));\n    }\n    centroids.push(centroid);\n  }\n  return centroids;\n}\n\n/**\n * Attributes data points to the nearest centroid's cluster\n * @param {Array} data - data set\n * @param {Array} centroids - array of centroid vectors\n * @return {Array} clusters - array of clusters\n */\nfunction clusterDataPoints(data, centroids) {\n  var clusters = [];\n  centroids.forEach(function () {\n    clusters.push([]);\n  });\n  data.forEach(function (point) {\n    var nearestCentroid = centroids[0];\n    centroids.forEach(function (centroid) {\n      if (\n        euclideanDistance(point, centroid) <\n        euclideanDistance(point, nearestCentroid)\n      ) {\n        nearestCentroid = centroid;\n      }\n    });\n    clusters[centroids.indexOf(nearestCentroid)].push(point);\n  });\n  return clusters;\n}\n\n/**\n * Calculates the new vectors of the centroids based on their respective clusters\n * @param {Array} clusters - array of clusters\n * @return {Array} centroids - new centroid vectors\n */\nfunction getNewCentroids(clusters) {\n  var centroids = [];\n  clusters.forEach(function (cluster) {\n    centroids.push(stats.meanPoint(cluster));\n  });\n  return centroids;\n}\n\n/**\n * Performs k-means clustering on a data set\n * @param {Array} data - data set\n * @param {Array} k - number of clusters for data points to be partitioned into\n * @return {Array} clusters - array of clusters (each containing an array of vectors representing a data point)\n */\nfunction kMeans(data, k) {\n  var centroids;\n  var clusters;\n  var oldClusters;\n  var converged = false;\n  const iterationLimit = 500;\n  var iterations = 0;\n\n  // STEP ONE: Initialise centroids\n  centroids = initialiseCentroidsRandomly(data, k);\n\n  while (!converged) {\n    console.log(\"iterated.\");\n    iterations += 1;\n    // STEP TWO: Cluster data points according to nearest centroid (assignment step)\n    oldClusters = clusters;\n    clusters = clusterDataPoints(data, centroids);\n\n    // Check for empty clusters. If so, just retry!\n    if (clusters.some((x) => x.length == 0)) {\n      console.log(\"Empty clusters found. Restarting k-means.\");\n      return kMeans(data, k);\n    }\n\n    console.log(iterations, iterationLimit);\n    if (clusters.equals(oldClusters) || iterations >= iterationLimit) {\n      converged = true;\n    }\n\n    // STEP THREE: Set centroids to mean point of points belonging to their respective clusters (update step)\n    centroids = getNewCentroids(clusters);\n  }\n  return clusters;\n}\n\nexport default kMeans;\n\n","import React from \"react\";\nimport styled from \"styled-components\";\n\nconst ColorBox = styled.div`\n  height: 150px;\n  width: 150px;\n  background: ${(props) => props.color};\n`;\n\nconst Cointainer = styled.div`\n  width: 80vw;\n  display: grid;\n  column-gap: 40px;\n  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));\n`;\n\nconst Pallete = ({ colors }) => {\n  console.log(colors);\n  return (\n    <Cointainer>\n      {colors.map((color, i) => (\n        <ColorBox key={i} color={color} />\n      ))}\n    </Cointainer>\n  );\n};\n\nexport default Pallete;\n","import React, { useState, useRef, useEffect } from \"react\";\nimport kMeans from \"./utils/clustering\";\nimport Pallete from \"./components/Pallete\";\nimport { meanPoint } from \"./utils/stats-utils\";\nimport \"./App.css\";\n\nfunction App() {\n  const [colors, setColors] = useState(null);\n  const canvasRef = useRef(null);\n  let ctx;\n  let canvas;\n  useEffect(() => {\n    canvas = canvasRef.current;\n    ctx = canvas.getContext(\"2d\");\n    //Our first draw\n    ctx.fillStyle = \"#000000\";\n    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n  }, []);\n\n  const loadImage = (e) => {\n    const reader = new FileReader();\n    reader.onload = function (event) {\n      const img = new Image();\n      img.src = event.target.result;\n      img.onload = function () {\n        canvas.width = 600;\n        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n\n        const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\n        let colors = [];\n        for (let i = 0; i < data.length; i += 4) {\n          colors.push([data[i], data[i + 1], data[i + 2], data[i + 3]]);\n        }\n        setColors(generatePallete(colors, 4));\n      };\n    };\n    reader.readAsDataURL(e.target.files[0]);\n  };\n\n  return (\n    <div className=\"App\">\n      <input\n        type=\"file\"\n        onChange={(e) => {\n          loadImage(e);\n        }}\n      />\n      {colors && <Pallete colors={colors} />}\n      <canvas ref={canvasRef} width={100} height={200} />\n    </div>\n  );\n}\n\nconst generatePallete = (allColours, k) => {\n  const clusters = kMeans(allColours, k);\n\n  // Calculate palette (mean colour of each cluster)\n  const colours = clusters.map((x) => meanPoint(x));\n  const palette = colours.map((x) => ({ r: x[0], g: x[1], b: x[2], a: x[3] }));\n  return palette.map((x) => rgbToHex(x.r, x.g, x.b));\n};\n\nfunction componentToHex(c) {\n  var hex = c.toString(16);\n  return hex.length == 1 ? \"0\" + hex : hex;\n}\n\nfunction rgbToHex(r, g, b) {\n  r = Math.round(r);\n  g = Math.round(g);\n  b = Math.round(b);\n  return \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}